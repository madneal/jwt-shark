
## 算法基础

### 插入排序

```go
// input : 5, 2, 4, 6, 1,3
// output : 1, 2, 3, 4, 5, 6
func insert_sort(nums [6]int) [6]int {
  j := 1
  for j < len(nums) {
    key := nums[j]
    i := j - 1
    for i >= 0 && nums[i] > key {
      nums[i+1] = nums[i]
      i = i - 1
    }
    nums[i + 1] = key
    j = j + 1
  }
  return nums
}
```

```go
// input : 5, 2, 4, 6, 1, 3
// output : 6, 5, 4, 3, 2, 1
func insert_sort(nums [6]int) [6]int {
  j := 1
  for j < len(nums) {
    key := nums[j]
    i := j - 1
    for i >= 0 && nums[i] < key {
      nums[i+1] = nums[i]
      i = i - 1
    }
    nums[i + 1] = key
    j = j + 1
  }
  return nums
}
```

### 分治法

分治模式：

* **分解**原问题为若干子问题，这鞋子问题是原问题的规模较小的实例
* **解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解
* **合并**这些子问题的解成原问题的解

归并排序：

* **分解**：分解待排序的 n 个元素的序列成各具 n/2 个元素的两个子序列
* **解决**：使用归并排序递归地排序两个子序列
* **合并**：合并两个已排序的子序列已产生的已排序的答案


